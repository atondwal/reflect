<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Claude Chatbot</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: "Times New Roman", Times, serif; height: 100vh; display: flex; flex-direction: column; background: #fff; }
  #chat-container { flex: 1; overflow-y: auto; padding: 12px 16px; }
  .cell { margin-bottom: 4px; border-left: 3px solid transparent; padding: 4px 8px; }
  .cell:hover { border-left-color: #ccc; }
  .cell-label { font-family: "Courier New", monospace; font-size: 12px; font-weight: bold; margin-bottom: 2px; }
  .cell.user .cell-label { color: #0057ad; }
  .cell.assistant .cell-label { color: #333; }
  .cell .cell-content { padding-left: 2px; font-size: 15px; line-height: 1.5; }
  .cell.user .cell-content { font-family: "Courier New", monospace; font-size: 14px; }
  #input-area { display: flex; padding: 8px 16px; gap: 8px; border-top: 1px solid #ddd; align-items: center; }
  .input-label { font-family: "Courier New", monospace; font-size: 12px; font-weight: bold; color: #0057ad; white-space: nowrap; }
  #input-area textarea { flex: 1; padding: 6px; font-family: "Courier New", monospace; font-size: 14px; border: none; outline: none; resize: none; overflow-y: hidden; min-height: 1.5em; }
  #input-area button { padding: 4px 12px; font-size: 13px; font-family: "Courier New", monospace; cursor: pointer; background: none; border: 1px solid #999; }
  #input-area button:disabled { opacity: 0.3; }
  #loading { display: none; padding: 4px 16px; font-family: "Courier New", monospace; font-size: 12px; color: #999; }
  .tool-bubble { background: #1a1a2e; color: #e0e0e0; margin-bottom: 4px; font-family: monospace; font-size: 13px; overflow: hidden; }
  .tool-bubble .tool-header { background: #16213e; color: #888; padding: 3px 8px; font-size: 11px; }
  .tool-bubble pre { margin: 0; padding: 8px; white-space: pre-wrap; word-break: break-all; max-height: 300px; overflow-y: auto; }
  .tool-bubble.executed .tool-header { color: #4caf50; }
  .tool-bubble .tool-result { border-top: 1px solid #2a2a4a; padding: 4px 8px; font-size: 11px; color: #888; max-height: 200px; overflow-y: auto; white-space: pre-wrap; }
  .tool-bubble .tool-result.error { color: #e57373; }
</style>
</head>
<body>

<div id="chat-container"></div>
<div id="loading">Claude is thinking...</div>
<div id="input-area">
  <span class="input-label" id="input-label">In[1]:=</span>
  <textarea id="user-input" rows="1" autocomplete="off"></textarea>
  <button id="send-btn" onclick="sendMessage()">Enter</button>
</div>

<script>
const chatContainer = document.getElementById('chat-container');
const userInput = document.getElementById('user-input');
const sendBtn = document.getElementById('send-btn');
const loading = document.getElementById('loading');
const inputLabel = document.getElementById('input-label');
let cellN = 1;
let chatId = null;

function esc(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

userInput.addEventListener('keydown', e => {
  if (e.key === 'Enter' && !e.shiftKey && !sendBtn.disabled) {
    e.preventDefault();
    sendMessage();
  }
});
userInput.addEventListener('input', () => {
  userInput.style.height = 'auto';
  userInput.style.height = userInput.scrollHeight + 'px';
});

function renderToolBubble(block, result) {
  const tb = document.createElement('div');
  tb.className = 'tool-bubble executed';
  const name = block.name || 'tool';
  tb.innerHTML = `<div class="tool-header">${esc(name)} \u2714</div><pre></pre>`;
  let displayInput;
  if (name === 'run_js') displayInput = block.input.code;
  else if (name === 'bash') displayInput = block.input.command;
  else if (name === 'write_file') displayInput = block.input.content;
  else if (name === 'edit_file') displayInput = `${block.input.old_string}\n\u2192\n${block.input.new_string}`;
  else if (name === 'grep') displayInput = `${block.input.pattern} ${block.input.path || '.'}`;
  else if (block.input.path) displayInput = block.input.path;
  else displayInput = JSON.stringify(block.input, null, 2);
  tb.querySelector('pre').textContent = displayInput;
  if (result !== undefined) {
    const r = document.createElement('div');
    r.className = 'tool-result' + (String(result).startsWith('Error') ? ' error' : '');
    r.textContent = '\u2192 ' + result;
    tb.appendChild(r);
  }
  return tb;
}

async function loadChat(id) {
  const res = await fetch('/chats/' + id);
  if (!res.ok) return;
  const data = await res.json();
  chatId = data.id;
  chatContainer.innerHTML = '';
  cellN = 1;

  // Build map of tool_use_id -> result from tool_result messages
  const toolResultMap = {};
  for (const msg of data.messages) {
    if (msg.role === 'user' && Array.isArray(msg.content)) {
      for (const item of msg.content) {
        if (item.type === 'tool_result') {
          toolResultMap[item.tool_use_id] = item.content;
        }
      }
    }
  }

  for (const msg of data.messages) {
    if (msg.role === 'user' && typeof msg.content === 'string') {
      appendMsg(msg.content, 'user', `In[${cellN}]:=`);
      cellN++;
    } else if (msg.role === 'assistant' && Array.isArray(msg.content)) {
      for (const block of msg.content) {
        if (block.type === 'text' && block.text.trim()) {
          appendMsg(block.text, 'assistant', `Out[${cellN}]=`);
        } else if (block.type === 'tool_use') {
          const result = toolResultMap[block.id];
          const tb = renderToolBubble(block, result);
          chatContainer.appendChild(tb);
          // Only replay run_js calls
          if (block.name === 'run_js') {
            try { eval(block.input.code); } catch(e) {
              const r = document.createElement('div');
              r.className = 'tool-result error';
              r.textContent = '\u2192 Error: ' + e.message;
              tb.appendChild(r);
            }
          }
        }
      }
    }
  }
  inputLabel.textContent = `In[${cellN}]:=`;
  chatContainer.scrollTop = chatContainer.scrollHeight;
}

// Load chat from URL, or resume most recent
const params = new URLSearchParams(location.search);
if (params.has('chat')) {
  loadChat(params.get('chat'));
} else if (!params.has('new')) {
  fetch('/chats').then(r => r.json()).then(data => {
    if (data.chats.length > 0) loadChat(data.chats[0].id);
  });
}

async function sendMessage() {
  const text = userInput.value.trim();
  if (!text) return;

  appendMsg(text, 'user', `In[${cellN}]:=`);
  userInput.value = '';
  sendBtn.disabled = true;
  loading.style.display = 'block';

  let currentBubble = null;
  let currentBubbleText = '';
  let toolBubble = null;
  let toolRawJson = '';
  let currentToolName = '';

  try {
    const res = await fetch('/chat', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({message: text, chat_id: chatId}),
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const {done, value} = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, {stream: true});
      const parts = buffer.split('\n\n');
      buffer = parts.pop();

      const events = [];
      for (const part of parts) {
        for (const line of part.split('\n')) {
          const trimmed = line.trim();
          if (!trimmed.startsWith('data: ')) continue;
          events.push(JSON.parse(trimmed.slice(6)));
        }
      }

      for (const data of events) {
          if (data.type === 'text_start') {
            loading.style.display = 'none';
            const cell = document.createElement('div');
            cell.className = 'cell assistant';
            cell.innerHTML = `<div class="cell-label">Out[${cellN}]=</div><div class="cell-content"></div>`;
            chatContainer.appendChild(cell);
            currentBubble = cell.querySelector('.cell-content');
            currentBubbleText = '';
          } else if (data.type === 'text_delta') {
            loading.style.display = 'none';
            if (currentBubble) {
              currentBubbleText += data.content;
              currentBubble.innerHTML = currentBubbleText;
              chatContainer.scrollTop = chatContainer.scrollHeight;
            }
          } else if (data.type === 'tool_start') {
            loading.style.display = 'none';
            currentToolName = data.name || 'run_js';
            toolRawJson = '';
            toolBubble = document.createElement('div');
            toolBubble.className = 'tool-bubble';
            toolBubble.innerHTML = `<div class="tool-header">${esc(currentToolName)}</div><pre></pre>`;
            chatContainer.appendChild(toolBubble);
            await new Promise(r => requestAnimationFrame(r));
          } else if (data.type === 'tool_delta') {
            toolRawJson += data.content;
            if (toolBubble) {
              let display = toolRawJson;
              // Extract first string value from JSON for cleaner display
              const match = display.match(/^\s*\{\s*"[^"]+"\s*:\s*"([\s\S]*)$/);
              if (match) {
                display = match[1].replace(/"\s*\}\s*$/, '');
                display = display.replace(/\\n/g, '\n').replace(/\\t/g, '\t')
                  .replace(/\\"/g, '"').replace(/\\\\/g, '\\');
              }
              toolBubble.querySelector('pre').textContent = display;
              chatContainer.scrollTop = chatContainer.scrollHeight;
              await new Promise(r => requestAnimationFrame(r));
            }
          } else if (data.type === 'js') {
            loading.style.display = 'none';
            if (toolBubble) {
              toolBubble.querySelector('pre').textContent = data.code;
              toolBubble.classList.add('executed');
              toolBubble.querySelector('.tool-header').textContent = 'run_js \u2714';
              toolBubble = null;
            }
            let result = 'OK';
            try {
              const val = eval(data.code);
              if (val !== undefined && val !== null) {
                result = String(val);
                if (result.length > 2000) result = result.slice(0, 2000) + '...';
              }
            } catch(err) {
              result = 'Error: ' + err.message;
              console.error('JS eval error:', err);
            }
            const executed = chatContainer.querySelector('.tool-bubble.executed:last-of-type');
            if (executed) {
              const res = document.createElement('div');
              res.className = 'tool-result' + (result.startsWith('Error:') ? ' error' : '');
              res.textContent = '\u2192 ' + result;
              executed.appendChild(res);
              chatContainer.scrollTop = chatContainer.scrollHeight;
            }
            if (data.tool_id) {
              fetch('/tool_result/' + data.tool_id, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({result: result}),
              });
            }
          } else if (data.type === 'tool_output') {
            loading.style.display = 'none';
            if (toolBubble) {
              toolBubble.classList.add('executed');
              toolBubble.querySelector('.tool-header').textContent = (data.name || 'tool') + ' \u2714';
              const res = document.createElement('div');
              res.className = 'tool-result' + (data.result && data.result.startsWith('Error') ? ' error' : '');
              res.textContent = '\u2192 ' + (data.result || 'OK');
              toolBubble.appendChild(res);
              toolBubble = null;
              chatContainer.scrollTop = chatContainer.scrollHeight;
            }
          } else if (data.type === 'error') {
            appendMsg('<p><strong>Error:</strong> ' + data.content + '</p>', 'assistant');
          } else if (data.type === 'done') {
            if (data.chat_id) {
              chatId = data.chat_id;
              history.replaceState(null, '', '?chat=' + chatId);
            }
          }
      }
    }
  } catch (err) {
    appendMsg('<p>Network error: ' + err.message + '</p>', 'assistant');
  }

  loading.style.display = 'none';
  sendBtn.disabled = false;
  cellN++;
  inputLabel.textContent = `In[${cellN}]:=`;
  userInput.focus();
}

function appendMsg(html, role, label) {
  const cell = document.createElement('div');
  cell.className = 'cell ' + role;
  if (label) {
    cell.innerHTML = `<div class="cell-label">${label}</div><div class="cell-content">${html}</div>`;
  } else {
    cell.innerHTML = `<div class="cell-content">${html}</div>`;
  }
  chatContainer.appendChild(cell);
  chatContainer.scrollTop = chatContainer.scrollHeight;
}
</script>
</body>
</html>
